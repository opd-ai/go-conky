package monitor

import (
	"net"
	"os"
	"path/filepath"
	"testing"
)

func TestHexToIP(t *testing.T) {
	tests := []struct {
		name    string
		hex     string
		want    string
		wantErr bool
	}{
		{
			name: "gateway 10.0.0.1",
			hex:  "0100000A", // 10.0.0.1 in little-endian hex
			want: "10.0.0.1",
		},
		{
			name: "gateway 192.168.1.1",
			hex:  "0101A8C0", // 192.168.1.1 in little-endian hex
			want: "192.168.1.1",
		},
		{
			name: "gateway 172.16.0.1",
			hex:  "010010AC", // 172.16.0.1 in little-endian hex
			want: "172.16.0.1",
		},
		{
			name: "loopback 127.0.0.1",
			hex:  "0100007F", // 127.0.0.1 in little-endian hex
			want: "127.0.0.1",
		},
		{
			name:    "invalid length",
			hex:     "0100",
			wantErr: true,
		},
		{
			name:    "invalid hex chars",
			hex:     "GHIJKLMN",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := hexToIPLE(tt.hex)
			if (err != nil) != tt.wantErr {
				t.Errorf("hexToIPLE() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got != tt.want {
				t.Errorf("hexToIPLE() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestParseRouteLine(t *testing.T) {
	tests := []struct {
		name        string
		line        string
		wantIface   string
		wantGateway string
		wantErr     bool
	}{
		{
			name:        "default route with gateway",
			line:        "eth0\t00000000\t0100000A\t0003\t0\t0\t100\t00000000\t0\t0\t0",
			wantIface:   "eth0",
			wantGateway: "10.0.0.1",
		},
		{
			name:        "non-default route",
			line:        "eth0\t0000000A\t00000000\t0001\t0\t0\t100\t0000FFFF\t0\t0\t0",
			wantIface:   "",
			wantGateway: "",
		},
		{
			name:    "insufficient fields",
			line:    "eth0\t00000000",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			iface, gateway, err := parseRouteLine(tt.line)
			if (err != nil) != tt.wantErr {
				t.Errorf("parseRouteLine() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr {
				if iface != tt.wantIface {
					t.Errorf("parseRouteLine() iface = %v, want %v", iface, tt.wantIface)
				}
				if gateway != tt.wantGateway {
					t.Errorf("parseRouteLine() gateway = %v, want %v", gateway, tt.wantGateway)
				}
			}
		})
	}
}

func TestReadDefaultGateway(t *testing.T) {
	// Create temp directory for test files
	tmpDir := t.TempDir()
	routePath := filepath.Join(tmpDir, "route")

	tests := []struct {
		name        string
		content     string
		wantGateway string
		wantIface   string
		wantErr     bool
	}{
		{
			name: "valid route table",
			content: `Iface	Destination	Gateway	Flags	RefCnt	Use	Metric	Mask	MTU	Window	IRTT
eth0	00000000	0100000A	0003	0	0	100	00000000	0	0	0
eth0	0000000A	00000000	0001	0	0	100	0000FFFF	0	0	0`,
			wantGateway: "10.0.0.1",
			wantIface:   "eth0",
		},
		{
			name: "no default route",
			content: `Iface	Destination	Gateway	Flags	RefCnt	Use	Metric	Mask	MTU	Window	IRTT
eth0	0000000A	00000000	0001	0	0	100	0000FFFF	0	0	0`,
			wantGateway: "",
			wantIface:   "",
		},
		{
			name:        "empty file",
			content:     "",
			wantGateway: "",
			wantIface:   "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := os.WriteFile(routePath, []byte(tt.content), 0644)
			if err != nil {
				t.Fatalf("failed to write test file: %v", err)
			}

			reader := &networkAddressReader{
				procRoutePath: routePath,
			}

			gateway, iface, err := reader.ReadDefaultGateway()
			if (err != nil) != tt.wantErr {
				t.Errorf("ReadDefaultGateway() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if gateway != tt.wantGateway {
				t.Errorf("ReadDefaultGateway() gateway = %v, want %v", gateway, tt.wantGateway)
			}
			if iface != tt.wantIface {
				t.Errorf("ReadDefaultGateway() iface = %v, want %v", iface, tt.wantIface)
			}
		})
	}
}

func TestReadDefaultGatewayMissingFile(t *testing.T) {
	reader := &networkAddressReader{
		procRoutePath: "/nonexistent/route",
	}

	_, _, err := reader.ReadDefaultGateway()
	if err == nil {
		t.Error("expected error for missing file")
	}
}

func TestReadNameservers(t *testing.T) {
	tmpDir := t.TempDir()
	resolvPath := filepath.Join(tmpDir, "resolv.conf")

	tests := []struct {
		name    string
		content string
		want    []string
		wantErr bool
	}{
		{
			name: "multiple nameservers",
			content: `# DNS configuration
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 1.1.1.1`,
			want: []string{"8.8.8.8", "8.8.4.4", "1.1.1.1"},
		},
		{
			name: "with comments and search",
			content: `# Generated by NetworkManager
search example.com
nameserver 192.168.1.1
# secondary DNS
nameserver 192.168.1.2`,
			want: []string{"192.168.1.1", "192.168.1.2"},
		},
		{
			name: "IPv6 nameserver",
			content: `nameserver 2001:4860:4860::8888
nameserver 8.8.8.8`,
			want: []string{"2001:4860:4860::8888", "8.8.8.8"},
		},
		{
			name:    "empty file",
			content: "",
			want:    nil,
		},
		{
			name:    "only comments",
			content: "# This is a comment\n; Another comment",
			want:    nil,
		},
		{
			name:    "invalid nameserver",
			content: "nameserver invalid-ip",
			want:    nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := os.WriteFile(resolvPath, []byte(tt.content), 0644)
			if err != nil {
				t.Fatalf("failed to write test file: %v", err)
			}

			reader := &networkAddressReader{
				resolvConfPath: resolvPath,
			}

			got, err := reader.ReadNameservers()
			if (err != nil) != tt.wantErr {
				t.Errorf("ReadNameservers() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if len(got) != len(tt.want) {
				t.Errorf("ReadNameservers() got %v, want %v", got, tt.want)
				return
			}

			for i, ns := range got {
				if ns != tt.want[i] {
					t.Errorf("ReadNameservers()[%d] = %v, want %v", i, ns, tt.want[i])
				}
			}
		})
	}
}

func TestReadNameserversMissingFile(t *testing.T) {
	reader := &networkAddressReader{
		resolvConfPath: "/nonexistent/resolv.conf",
	}

	// Should return nil, nil for missing file (common in containers)
	got, err := reader.ReadNameservers()
	if err != nil {
		t.Errorf("ReadNameservers() expected nil error for missing file, got %v", err)
	}
	if got != nil {
		t.Errorf("ReadNameservers() expected nil result for missing file, got %v", got)
	}
}

// mockInterface simulates a network interface for testing.
type mockInterface struct {
	name  string
	addrs []net.Addr
}

// mockAddr implements net.Addr for testing.
type mockAddr struct {
	network string
	addr    string
}

func (m mockAddr) Network() string { return m.network }
func (m mockAddr) String() string  { return m.addr }

func TestReadInterfaceAddresses(t *testing.T) {
	tests := []struct {
		name       string
		interfaces []net.Interface
		addrsMap   map[string][]net.Addr
		wantResult map[string]InterfaceAddrs
	}{
		{
			name: "single interface with IPv4 and IPv6",
			interfaces: []net.Interface{
				{Name: "eth0"},
			},
			addrsMap: map[string][]net.Addr{
				"eth0": {
					mockAddr{addr: "192.168.1.100/24"},
					mockAddr{addr: "fe80::1/64"},
				},
			},
			wantResult: map[string]InterfaceAddrs{
				"eth0": {
					IPv4: []string{"192.168.1.100"},
					IPv6: []string{"fe80::1"},
				},
			},
		},
		{
			name: "multiple interfaces",
			interfaces: []net.Interface{
				{Name: "eth0"},
				{Name: "lo"},
			},
			addrsMap: map[string][]net.Addr{
				"eth0": {mockAddr{addr: "10.0.0.5/24"}},
				"lo":   {mockAddr{addr: "127.0.0.1/8"}},
			},
			wantResult: map[string]InterfaceAddrs{
				"eth0": {IPv4: []string{"10.0.0.5"}, IPv6: []string{}},
				"lo":   {IPv4: []string{"127.0.0.1"}, IPv6: []string{}},
			},
		},
		{
			name: "multiple IPv4 addresses",
			interfaces: []net.Interface{
				{Name: "eth0"},
			},
			addrsMap: map[string][]net.Addr{
				"eth0": {
					mockAddr{addr: "192.168.1.100/24"},
					mockAddr{addr: "192.168.1.101/24"},
				},
			},
			wantResult: map[string]InterfaceAddrs{
				"eth0": {
					IPv4: []string{"192.168.1.100", "192.168.1.101"},
					IPv6: []string{},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			reader := &networkAddressReader{
				getInterfacesFn: func() ([]net.Interface, error) {
					return tt.interfaces, nil
				},
				getAddrsFn: func(iface *net.Interface) ([]net.Addr, error) {
					return tt.addrsMap[iface.Name], nil
				},
			}

			got, err := reader.ReadInterfaceAddresses()
			if err != nil {
				t.Errorf("ReadInterfaceAddresses() error = %v", err)
				return
			}

			for ifaceName, wantAddrs := range tt.wantResult {
				gotAddrs, ok := got[ifaceName]
				if !ok {
					t.Errorf("ReadInterfaceAddresses() missing interface %s", ifaceName)
					continue
				}

				if len(gotAddrs.IPv4) != len(wantAddrs.IPv4) {
					t.Errorf("ReadInterfaceAddresses() %s IPv4 count = %d, want %d",
						ifaceName, len(gotAddrs.IPv4), len(wantAddrs.IPv4))
				}
				for i, addr := range gotAddrs.IPv4 {
					if addr != wantAddrs.IPv4[i] {
						t.Errorf("ReadInterfaceAddresses() %s IPv4[%d] = %v, want %v",
							ifaceName, i, addr, wantAddrs.IPv4[i])
					}
				}

				if len(gotAddrs.IPv6) != len(wantAddrs.IPv6) {
					t.Errorf("ReadInterfaceAddresses() %s IPv6 count = %d, want %d",
						ifaceName, len(gotAddrs.IPv6), len(wantAddrs.IPv6))
				}
				for i, addr := range gotAddrs.IPv6 {
					if addr != wantAddrs.IPv6[i] {
						t.Errorf("ReadInterfaceAddresses() %s IPv6[%d] = %v, want %v",
							ifaceName, i, addr, wantAddrs.IPv6[i])
					}
				}
			}
		})
	}
}

func TestNewNetworkAddressReader(t *testing.T) {
	reader := newNetworkAddressReader()

	if reader.procRoutePath != "/proc/net/route" {
		t.Errorf("expected procRoutePath /proc/net/route, got %s", reader.procRoutePath)
	}

	if reader.resolvConfPath != "/etc/resolv.conf" {
		t.Errorf("expected resolvConfPath /etc/resolv.conf, got %s", reader.resolvConfPath)
	}

	if reader.getInterfacesFn == nil {
		t.Error("getInterfacesFn should not be nil")
	}

	if reader.getAddrsFn == nil {
		t.Error("getAddrsFn should not be nil")
	}
}
